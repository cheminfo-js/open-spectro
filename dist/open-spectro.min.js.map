{"version":3,"sources":["webpack:///open-spectro/webpack/universalModuleDefinition","webpack:///open-spectro/open-spectro.min.js","webpack:///open-spectro/webpack/bootstrap ac4c3406dfea0c5b2288","webpack:///open-spectro/./src/index.js","webpack:///open-spectro/./src/wavelengthToColor.js","webpack:///open-spectro/./src/parse.js","webpack:///open-spectro/./src/process.js","webpack:///open-spectro/./src/util.js","webpack:///open-spectro/./src/getAnnotations.js","webpack:///open-spectro/./src/getChart.js","webpack:///open-spectro/./src/types.js","webpack:///open-spectro/./src/getTabDelimited.js","webpack:///open-spectro/./src/load.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","wavelengthToColor","parse","process","getAnnotations","Util","getChart","getTabDelimited","load","wavelengthTocolor","wavelength","red","green","blue","alpha","color","absorbance","experiment","reference","results","Array","length","i","Math","log10","transmittance","parseData","lines","y","currentValue","fields","split","j","field","trim","match","firstChar","substring","value","difference","indexOf","substr","push","parseInfo","info","result","type","fieldType","replace","fieldValue","intensity","percentIntensity","round","values","redPoint","greenPoint","bluePoint","nMRed","nMGreen","nMBlue","backgroundMin","backgroundMax","convertToObject","spectra","spectrum","addInfo","Object","keys","forEach","key","addAbsorbanceTransmittance","Z","E","a","JSON","stringify","A","t","T","addTabDelimited","tab","toXY","addX","diffPoints","diffNM","firstNM","lastNM","x","text","options","create","blocs","part","bloc","slice","smooth","nbPixels","array","shift","floor","average","normalize","min","Number","MAX_VALUE","max","MIN_VALUE","join","toArray","getAnnotation","pixel","height","fillColor","position","strokeWidth","annotations","types","experiments","channels","index","isArray","yLabel","label","yUnit","chart","title","axis","data","showName","showConcentration","showComment","showChannel","concentration","name","comment","undefined","xAxis","yAxis","defaultStyle","lineColor","lineWidth","R","G","B","W","addHeaders","headers","currentData","toPrecision","header","datum","selected","current"],"mappings":"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","file":"open-spectro.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openSpectro\"] = factory();\n\telse\n\t\troot[\"openSpectro\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openSpectro\"] = factory();\n\telse\n\t\troot[\"openSpectro\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar wavelengthToColor = __webpack_require__(1);\n\tvar parse = __webpack_require__(2);\n\tvar process = __webpack_require__(3);\n\tvar getAnnotations = __webpack_require__(5);\n\tvar Util = __webpack_require__(4);\n\tvar getChart = __webpack_require__(6);\n\tvar getTabDelimited = __webpack_require__(8);\n\tvar load = __webpack_require__(9);\n\t\n\tmodule.exports.wavelengthTocolor=wavelengthToColor;\n\tmodule.exports.parse=parse;\n\tmodule.exports.process=process;\n\tmodule.exports.getAnnotations=getAnnotations;\n\tmodule.exports.Util=Util;\n\tmodule.exports.getChart=getChart;\n\tmodule.exports.getTabDelimited=getTabDelimited;\n\tmodule.exports.load=load;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function (wavelength) {\n\t    var red;\n\t    var green;\n\t    var blue;\n\t    var alpha;\n\t\n\t    if (wavelength >= 380 && wavelength < 440) {\n\t        red = -1 * (wavelength - 440) / (440 - 380);\n\t        green = 0;\n\t        blue = 1;\n\t    } else if (wavelength >= 440 && wavelength < 490) {\n\t        red = 0;\n\t        green = (wavelength - 440) / (490 - 440);\n\t        blue = 1;\n\t    } else if (wavelength >= 490 && wavelength < 510) {\n\t        red = 0;\n\t        green = 1;\n\t        blue = -1 * (wavelength - 510) / (510 - 490);\n\t    } else if (wavelength >= 510 && wavelength < 580) {\n\t        red = (wavelength - 510) / (580 - 510);\n\t        green = 1;\n\t        blue = 0;\n\t    } else if (wavelength >= 580 && wavelength < 645) {\n\t        red = 1;\n\t        green = -1 * (wavelength - 645) / (645 - 580);\n\t        blue = 0.0;\n\t    } else if (wavelength >= 645 && wavelength <= 780) {\n\t        red = 1;\n\t        green = 0;\n\t        blue = 0;\n\t    } else {\n\t        red = 0;\n\t        green = 0;\n\t        blue = 0;\n\t    }\n\t\n\t    // outside visible spectrum\n\t    if (wavelength > 780 || wavelength < 380) {\n\t        alpha = 0;\n\t    } else if (wavelength > 700) {\n\t        alpha = (780 - wavelength) / (780 - 700);\n\t    } else if (wavelength < 420) {\n\t        alpha = (wavelength - 380) / (420 - 380);\n\t    } else {\n\t        alpha = 1;\n\t    }\n\t\n\t    return {\n\t        color: \"rgba(\" + (red * 100) + \"%,\" + (green * 100) + \"%,\" + (blue * 100) + \"%, \" + alpha + \")\",\n\t        red: red,\n\t        green: green,\n\t        blue: blue,\n\t        alpha: alpha\n\t    }\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar process=__webpack_require__(3);\n\tvar Util=__webpack_require__(4);\n\t\n\t\n\tfunction absorbance(experiment, reference) {\n\t    var results=new Array(experiment.length);\n\t    for (var i=0; i<experiment.length; i++) {\n\t        results[i]=-Math.log10(experiment[i]/reference[i]);\n\t    }\n\t    return results;\n\t}\n\t\n\tfunction transmittance(experiment, reference) {\n\t    var results=new Array(experiment.length);\n\t    for (var i=0; i<experiment.length; i++) {\n\t        results[i]=experiment[i]/reference[i]*100;\n\t    }\n\t    return results;\n\t}\n\t\n\t\n\t\n\tvar difference=['r','q','p','o','n','m','l','k','j','%','J','K','L','M','N','O','P','Q','R'];\n\t\n\tfunction parseData(lines) {\n\t    var y=[];\n\t    var currentValue=0;\n\t    for (var i=0; i<lines.length; i++) {\n\t        var line=lines[i];\n\t        var fields=lines[i].split(/( ?(?=[a-zA-Z%])| +(?=[^a-zA-Z%]))/);\n\t        for (var j=0; j<fields.length; j++) {\n\t            var field=fields[j];\n\t            if (field.trim().length>0) {\n\t                // we check if we convert the first character\n\t                if (field.match(/^[j-rJ-R%]/)) {\n\t                    var firstChar=field.substring(0,1);\n\t                    var value=difference.indexOf(firstChar)-9;\n\t                    currentValue+=(value+field.substr(1))>>0;\n\t                } else {\n\t                    currentValue=fields[j]>>0;\n\t                }\n\t                y.push(currentValue);\n\t            }\n\t        }\n\t    }\n\t    return y;\n\t}\n\t\n\t\n\t\n\tfunction parseInfo(info) {\n\t    var result={};\n\t    var fields=info.split(\",\");\n\t    result.type=fields[0];\n\t    for (var i=1; i<fields.length; i++) {\n\t        var field=fields[i];\n\t        var fieldType=field.replace(/^([A-Z]*)(.*)$/,\"$1\");\n\t        var fieldValue=field.replace(/^([A-Z]*)(.*)$/,\"$2\");\n\t        switch(fieldType) {\n\t            case 'I':\n\t                result.intensity=fieldValue>>0;\n\t                result.percentIntensity=Math.round(((fieldValue>>0)/256)*100);\n\t                break;\n\t            case 'RGB':\n\t                var values=fieldValue.split(\"/\");\n\t                result.redPoint=values[0]>>0;\n\t                result.greenPoint=values[1]>>0;\n\t                result.bluePoint=values[2]>>0;\n\t                break;\n\t            case 'REF':\n\t                var values=fieldValue.split(\"/\");\n\t                result.nMRed=values[0]>>0;\n\t                result.nMGreen=values[1]>>0;\n\t                result.nMBlue=values[2]>>0;\n\t                break;\n\t            case 'BG':\n\t                var values=fieldValue.split(\"/\");\n\t                result.backgroundMin=values[0]>>0;\n\t                result.backgroundMax=values[1]>>0;\n\t                break;\n\t            default:\n\t                result[fieldType]=fieldValue;\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\t/*\n\t types are normally: R G B W\n\t Z (background), E (experimental)\n\t A: absorbance\n\t T: transmittance\n\t  */\n\t\n\tfunction convertToObject(spectra) {\n\t    var result={};\n\t    for (var i=0; i<spectra.length; i++) {\n\t        var spectrum=spectra[i];\n\t        result[spectrum.type]=spectrum;\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction addInfo(spectra, info) {\n\t    var info=info || {};\n\t    for (var type in spectra) {\n\t        var spectrum=spectra[type];\n\t        Object.keys(info).forEach(function(key) {\n\t            spectrum.info = spectrum.info || {};\n\t            if (key!=='data') {\n\t                spectrum.info[key]=info[key];\n\t            }\n\t        });\n\t    }\n\t}\n\t\n\tfunction addAbsorbanceTransmittance(spectra) {\n\t    // if we have Z and E we calculate absorbance and transmittance\n\t    if (spectra.Z && spectra.E) {\n\t        var a=JSON.parse(JSON.stringify(spectra.Z));\n\t        a.type=\"A\";\n\t        a.y=absorbance(spectra.E.y, spectra.Z.y);\n\t        spectra.A=a;\n\t        var t=JSON.parse(JSON.stringify(spectra.Z));\n\t        t.type=\"T\";\n\t        t.y=transmittance(spectra.E.y, spectra.Z.y);\n\t        spectra.T=t;\n\t    }\n\t}\n\t\n\tfunction addTabDelimited(spectra) {\n\t    for (var key in spectra) {\n\t        var spectrum = spectra[key];\n\t        spectrum.tab = Util.toXY(spectrum);\n\t    }\n\t}\n\t\n\tfunction addX(spectra) {\n\t    for (var key in spectra) {\n\t        var spectrum=spectra[key];\n\t        var diffPoints=spectrum.redPoint-spectrum.bluePoint;\n\t        var diffNM=(spectrum.nMRed-spectrum.nMBlue)/(diffPoints-1);\n\t        var length=spectrum.y.length;\n\t\n\t        // we will add all the color spectrum\n\t        // need to guess the nm of the first point and last point\n\t        var firstNM=spectrum.nMBlue-spectrum.bluePoint*diffNM;\n\t        var lastNM=spectrum.nMRed+(length-spectrum.redPoint)*diffNM;\n\t        spectrum.x=[];\n\t        for (var i=0; i<length; i++) {\n\t            var wavelength=firstNM+(lastNM-firstNM)/(length-1)*i;\n\t            spectrum.x.push(wavelength);\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports = function (text, options) {\n\t    if (! text) return [];\n\t    var options=Object.create(options || {});\n\t    var blocs=text.split(/[\\r\\n]*>/m);\n\t    var results=[];\n\t    for (var part=0; part<blocs.length; part++) {\n\t        var bloc=blocs[part];\n\t        var result=[];\n\t        var lines=bloc.split(/[\\r\\n]+/);\n\t        // first line is the info line\n\t        var info=lines[0];\n\t        if (info && info.match(/^[A-Z]/)) {\n\t            var result=parseInfo(info);\n\t            result.y=parseData(lines.slice(1));\n\t            results.push(result);\n\t        }\n\t\n\t    }\n\t    var spectra=convertToObject(results);\n\t    addAbsorbanceTransmittance(spectra);\n\t    addInfo(spectra, options.info);\n\t    process(spectra, options);\n\t    addX(spectra);\n\t    addTabDelimited(spectra);\n\t\n\t    return spectra;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// process spectra\n\t\n\tfunction smooth(spectrum, nbPixels) {\n\t    var result=[];\n\t    var array=spectrum.y;\n\t    var shift=Math.floor(nbPixels/2);\n\t\n\t    for (var i=shift; i<(array.length-shift-1); i++) {\n\t        var average=0;\n\t        for (var j=i-shift; j<i-shift+nbPixels; j++) {\n\t            average+=array[j];\n\t        }\n\t        result.push(average/nbPixels)\n\t    }\n\t\n\t    spectrum.y=result;\n\t    // need to shift the reference point\n\t    spectrum.redPoint-=shift;\n\t    spectrum.bluePoint-=shift;\n\t    spectrum.greenPoint-=shift;\n\t};\n\t\n\tfunction normalize(spectrum) {\n\t    var array=spectrum.y;\n\t    var min=Number.MAX_VALUE;\n\t    var max=Number.MIN_VALUE;\n\t    for (var i=0; i<array.length; i++) {\n\t        if (array[i]<min) min=array[i];\n\t        if (array[i]>max) max=array[i];\n\t    }\n\t    if (min!=max) {\n\t        for (var i=0; i<array.length; i++) {\n\t            array[i]=(array[i]-min)/(max-min);\n\t        }\n\t    } else {\n\t        for (var i=0; i<array.length; i++) {\n\t            array[i]=0.5;\n\t        }\n\t    }\n\t    spectrum.y=array;\n\t}\n\t\n\tmodule.exports=function(spectra, options) {\n\t    var options=Object.create(options||{});\n\t\n\t    for (var key in spectra) {\n\t        if (options.smooth) {\n\t            smooth(spectra[key], options.smooth);\n\t        }\n\t        if (options.normalize) {\n\t            normalize(spectra[key]);\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports.toXY=function(spectrum) {\n\t    var x=spectrum.x;\n\t    var y=spectrum.y;\n\t    var result=[];\n\t    for (var i=0; i< x.length; i++) {\n\t        result.push(x[i]+\"\\t\"+y[i]);\n\t    }\n\t    return result.join('\\r\\n');\n\t}\n\t\n\tmodule.exports.toArray=function(spectra) {\n\t    var array=[];\n\t    for (var key in spectra) {\n\t        array.push(spectra[key]);\n\t    }\n\t    return array;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar wavelengthToColor = __webpack_require__(1);\n\t\n\t\n\tfunction getAnnotation(pixel, color, height) {\n\t    return {\n\t        \"fillColor\": color,\n\t        \"type\": \"rect\",\n\t        \"position\": [{\n\t            \"y\": \"0px\",\n\t            \"x\": pixel+2\n\t        },{\n\t            \"y\": height+\"px\",\n\t            \"x\": pixel-1\n\t        }],\n\t        \"strokeWidth\":0.0001\n\t    };\n\t}\n\t\n\tmodule.exports=function(spectrum) {\n\t    if (! spectrum) return;\n\t    var annotations=[];\n\t    annotations.push(getAnnotation(spectrum.nMRed,\"red\",15));\n\t    annotations.push(getAnnotation(spectrum.nMBlue,\"blue\",15));\n\t    annotations.push(getAnnotation(spectrum.nMGreen,\"green\",15));\n\t\n\t    var x=spectrum.x;\n\t    for (var i=0; i<x.length; i++) {\n\t        var color=wavelengthToColor(x[i]).color;\n\t        annotations.push(getAnnotation(x[i],color,10));\n\t    }\n\t    return annotations;\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// convert an experiment, an array of spectra, to a chart\n\t\n\tvar types=__webpack_require__(7);\n\t\n\t\n\t\n\tmodule.exports=function (experiments, options) {\n\t    var options=options || {};\n\t    var channels=options.channels || 'RGBWT';\n\t    var index=options.index;\n\t\n\t    if (! Array.isArray(experiments)) experiments=[experiments];\n\t\n\t    var yLabel=\"Y axis\";\n\t    if (channels.length===1) {\n\t        yLabel=types[channels].label + \"(\"+types[channels].yUnit+\")\";\n\t    }\n\t\n\t    var chart = {\n\t        title: \"Open Spectrophotometer results\",\n\t        \"axis\": [\n\t            {\n\t                \"label\": \"Wavelength (nm)\"\n\t            },\n\t            {\n\t                \"label\": yLabel\n\t            }\n\t        ],\n\t        \"data\": []\n\t    }\n\t\n\t    var counter=0;\n\t\n\t    var showName=false;\n\t    var showConcentration=false;\n\t    var showComment=false;\n\t    var showChannel=(channels.length===1) ? false : true;\n\t\n\t    experiments.forEach(function(experiment) {\n\t        experiment.info=experiment.info || {};\n\t    });\n\t\n\t    for (var i=1; i<experiments.length; i++) {\n\t        if (experiments[0].info.concentration !== experiments[i].info.concentration ) showConcentration=true;\n\t        if (experiments[0].info.name !== experiments[i].info.name ) showName=true;\n\t        if (experiments[0].info.comment !== experiments[i].info.comment ) showComment=true;\n\t    }\n\t\n\t    for (var i = 0; i < experiments.length; i++) {\n\t        if ((index === undefined) || (index === i)) {\n\t            var experiment=experiments[i];\n\t            for (var key in experiment) {\n\t                if (channels.indexOf(key)>-1) {\n\t                    var data=experiment[key];\n\t\n\t                    var label=\"\";\n\t                    if (showName) label+=data.info.name;\n\t                    if (showConcentration) {\n\t                        if (showName) label+=' ('+data.info.concentration+')';\n\t                        else label+=data.info.concentration;\n\t                    }\n\t                    if (showComment) {\n\t                        if (label) label+=' ';\n\t                        label+=data.info.comment;\n\t                    }\n\t                    if (showChannel) {\n\t                        if (label) label+=' ';\n\t                        label+=key;\n\t                    }\n\t\n\t                    chart.data.push({\n\t                        \"x\":data.x,\n\t                        \"y\":data.y,\n\t                        \"label\":label,\n\t                        xAxis: 0,\n\t                        yAxis: 1,\n\t                        defaultStyle: {\n\t                            lineColor: types[key].color,\n\t                            lineWidth: 2\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return {\n\t        type:'chart',\n\t        value: chart\n\t    };\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t types are normally: R G B W\n\t Z (background), E (experimental)\n\t A: absorbance\n\t T: transmittance\n\t */\n\t\n\tmodule.exports = {\n\t    R:{label:'red', yUnit:\"relative\", color:'red'},\n\t    G:{label:'green', yUnit:\"relative\", color:'green'},\n\t    B:{label:'blue', yUnit:\"relative\", color:'blue'},\n\t    W:{label:'white', yUnit:\"relative\", color:'black'},\n\t    Z:{label:'background', yUnit:\"relative\", color:'grey'},\n\t    E:{label:'experimental', yUnit:\"relative\", color:'black'},\n\t    A:{label:'absorbance', yUnit:\"(%)\", color:'black'},\n\t    T:{label:'transmittance', yUnit:\"(%)\", color:'black'}\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// convert experiments to a tab-delimited file\n\t\n\tvar headers=[];\n\theaders[0]=[]; // name\n\theaders[1]=[]; // concentration\n\theaders[2]=[]; // comment\n\theaders[3]=[]; // type\n\t\n\tmodule.exports=function (experiments, channels, index) {\n\t    var channels = channels || 'RGBWT';\n\t\n\t    if (! Array.isArray(experiments)) experiments=[experiments];\n\t\n\t    var data=[];\n\t\n\t\n\t\n\t    var counter=0;\n\t    for (var i = 0; i < experiments.length; i++) {\n\t        if ((index === undefined) || (index === i)) {\n\t            var experiment=experiments[i];\n\t\n\t            addHeaders(experiment, 'X');\n\t            var currentData=experiment[Object.keys(experiment)[0]];\n\t            for (var j=0; j<currentData.x.length; j++) {\n\t                if (! data[j]) data[j]=[];\n\t                data[j].push(currentData.x[j].toPrecision(4));\n\t            }\n\t\n\t            for (var key in experiment) {\n\t                if (channels.indexOf(key)>-1) {\n\t                    addHeaders(experiment,key);\n\t                    var currentData=experiment[key];\n\t                    for (var j=0; j<currentData.y.length; j++) {\n\t                        data[j].push(currentData.y[j].toPrecision(4));\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    var lines=[];\n\t    for (var i=0; i<headers.length; i++) {\n\t        var header=headers[i];\n\t        lines.push(header.join(\"\\t\"));\n\t    }\n\t    for (var i=0; i<data.length; i++) {\n\t        var datum=data[i];\n\t        lines.push(datum.join(\"\\t\"));\n\t    }\n\t    var result=lines.join(\"\\r\\n\");\n\t    return result;\n\t\n\t}\n\t\n\tfunction addHeaders(experiment, type) {\n\t    headers[0].push(experiment.info.name);\n\t    headers[1].push(experiment.info.concentration);\n\t    headers[2].push(experiment.info.comment);\n\t    headers[3].push(type);\n\t}\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar parse=__webpack_require__(2);\n\t\n\t// We load a json containing all the einformations\n\t\n\t\n\tmodule.exports = function (selected, options) {\n\t    var options=Object.create(options||{});\n\t    var experiments=[];\n\t    selected.forEach(function(current) {\n\t        options.info=current;\n\t        var experiment=parse(current.data, options);\n\t        experiments.push(experiment);\n\t    });\n\t    return experiments;\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** open-spectro.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ac4c3406dfea0c5b2288\n **/","'use strict';\n\n\nvar wavelengthToColor = require('./wavelengthToColor');\nvar parse = require('./parse');\nvar process = require('./process');\nvar getAnnotations = require('./getAnnotations');\nvar Util = require('./util');\nvar getChart = require('./getChart');\nvar getTabDelimited = require('./getTabDelimited');\nvar load = require('./load');\n\nmodule.exports.wavelengthTocolor=wavelengthToColor;\nmodule.exports.parse=parse;\nmodule.exports.process=process;\nmodule.exports.getAnnotations=getAnnotations;\nmodule.exports.Util=Util;\nmodule.exports.getChart=getChart;\nmodule.exports.getTabDelimited=getTabDelimited;\nmodule.exports.load=load;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function (wavelength) {\n    var red;\n    var green;\n    var blue;\n    var alpha;\n\n    if (wavelength >= 380 && wavelength < 440) {\n        red = -1 * (wavelength - 440) / (440 - 380);\n        green = 0;\n        blue = 1;\n    } else if (wavelength >= 440 && wavelength < 490) {\n        red = 0;\n        green = (wavelength - 440) / (490 - 440);\n        blue = 1;\n    } else if (wavelength >= 490 && wavelength < 510) {\n        red = 0;\n        green = 1;\n        blue = -1 * (wavelength - 510) / (510 - 490);\n    } else if (wavelength >= 510 && wavelength < 580) {\n        red = (wavelength - 510) / (580 - 510);\n        green = 1;\n        blue = 0;\n    } else if (wavelength >= 580 && wavelength < 645) {\n        red = 1;\n        green = -1 * (wavelength - 645) / (645 - 580);\n        blue = 0.0;\n    } else if (wavelength >= 645 && wavelength <= 780) {\n        red = 1;\n        green = 0;\n        blue = 0;\n    } else {\n        red = 0;\n        green = 0;\n        blue = 0;\n    }\n\n    // outside visible spectrum\n    if (wavelength > 780 || wavelength < 380) {\n        alpha = 0;\n    } else if (wavelength > 700) {\n        alpha = (780 - wavelength) / (780 - 700);\n    } else if (wavelength < 420) {\n        alpha = (wavelength - 380) / (420 - 380);\n    } else {\n        alpha = 1;\n    }\n\n    return {\n        color: \"rgba(\" + (red * 100) + \"%,\" + (green * 100) + \"%,\" + (blue * 100) + \"%, \" + alpha + \")\",\n        red: red,\n        green: green,\n        blue: blue,\n        alpha: alpha\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/wavelengthToColor.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\nvar process=require('./process.js');\nvar Util=require('./util.js');\n\n\nfunction absorbance(experiment, reference) {\n    var results=new Array(experiment.length);\n    for (var i=0; i<experiment.length; i++) {\n        results[i]=-Math.log10(experiment[i]/reference[i]);\n    }\n    return results;\n}\n\nfunction transmittance(experiment, reference) {\n    var results=new Array(experiment.length);\n    for (var i=0; i<experiment.length; i++) {\n        results[i]=experiment[i]/reference[i]*100;\n    }\n    return results;\n}\n\n\n\nvar difference=['r','q','p','o','n','m','l','k','j','%','J','K','L','M','N','O','P','Q','R'];\n\nfunction parseData(lines) {\n    var y=[];\n    var currentValue=0;\n    for (var i=0; i<lines.length; i++) {\n        var line=lines[i];\n        var fields=lines[i].split(/( ?(?=[a-zA-Z%])| +(?=[^a-zA-Z%]))/);\n        for (var j=0; j<fields.length; j++) {\n            var field=fields[j];\n            if (field.trim().length>0) {\n                // we check if we convert the first character\n                if (field.match(/^[j-rJ-R%]/)) {\n                    var firstChar=field.substring(0,1);\n                    var value=difference.indexOf(firstChar)-9;\n                    currentValue+=(value+field.substr(1))>>0;\n                } else {\n                    currentValue=fields[j]>>0;\n                }\n                y.push(currentValue);\n            }\n        }\n    }\n    return y;\n}\n\n\n\nfunction parseInfo(info) {\n    var result={};\n    var fields=info.split(\",\");\n    result.type=fields[0];\n    for (var i=1; i<fields.length; i++) {\n        var field=fields[i];\n        var fieldType=field.replace(/^([A-Z]*)(.*)$/,\"$1\");\n        var fieldValue=field.replace(/^([A-Z]*)(.*)$/,\"$2\");\n        switch(fieldType) {\n            case 'I':\n                result.intensity=fieldValue>>0;\n                result.percentIntensity=Math.round(((fieldValue>>0)/256)*100);\n                break;\n            case 'RGB':\n                var values=fieldValue.split(\"/\");\n                result.redPoint=values[0]>>0;\n                result.greenPoint=values[1]>>0;\n                result.bluePoint=values[2]>>0;\n                break;\n            case 'REF':\n                var values=fieldValue.split(\"/\");\n                result.nMRed=values[0]>>0;\n                result.nMGreen=values[1]>>0;\n                result.nMBlue=values[2]>>0;\n                break;\n            case 'BG':\n                var values=fieldValue.split(\"/\");\n                result.backgroundMin=values[0]>>0;\n                result.backgroundMax=values[1]>>0;\n                break;\n            default:\n                result[fieldType]=fieldValue;\n        }\n    }\n    return result;\n}\n\n/*\n types are normally: R G B W\n Z (background), E (experimental)\n A: absorbance\n T: transmittance\n  */\n\nfunction convertToObject(spectra) {\n    var result={};\n    for (var i=0; i<spectra.length; i++) {\n        var spectrum=spectra[i];\n        result[spectrum.type]=spectrum;\n    }\n    return result;\n}\n\nfunction addInfo(spectra, info) {\n    var info=info || {};\n    for (var type in spectra) {\n        var spectrum=spectra[type];\n        Object.keys(info).forEach(function(key) {\n            spectrum.info = spectrum.info || {};\n            if (key!=='data') {\n                spectrum.info[key]=info[key];\n            }\n        });\n    }\n}\n\nfunction addAbsorbanceTransmittance(spectra) {\n    // if we have Z and E we calculate absorbance and transmittance\n    if (spectra.Z && spectra.E) {\n        var a=JSON.parse(JSON.stringify(spectra.Z));\n        a.type=\"A\";\n        a.y=absorbance(spectra.E.y, spectra.Z.y);\n        spectra.A=a;\n        var t=JSON.parse(JSON.stringify(spectra.Z));\n        t.type=\"T\";\n        t.y=transmittance(spectra.E.y, spectra.Z.y);\n        spectra.T=t;\n    }\n}\n\nfunction addTabDelimited(spectra) {\n    for (var key in spectra) {\n        var spectrum = spectra[key];\n        spectrum.tab = Util.toXY(spectrum);\n    }\n}\n\nfunction addX(spectra) {\n    for (var key in spectra) {\n        var spectrum=spectra[key];\n        var diffPoints=spectrum.redPoint-spectrum.bluePoint;\n        var diffNM=(spectrum.nMRed-spectrum.nMBlue)/(diffPoints-1);\n        var length=spectrum.y.length;\n\n        // we will add all the color spectrum\n        // need to guess the nm of the first point and last point\n        var firstNM=spectrum.nMBlue-spectrum.bluePoint*diffNM;\n        var lastNM=spectrum.nMRed+(length-spectrum.redPoint)*diffNM;\n        spectrum.x=[];\n        for (var i=0; i<length; i++) {\n            var wavelength=firstNM+(lastNM-firstNM)/(length-1)*i;\n            spectrum.x.push(wavelength);\n        }\n    }\n}\n\nmodule.exports = function (text, options) {\n    if (! text) return [];\n    var options=Object.create(options || {});\n    var blocs=text.split(/[\\r\\n]*>/m);\n    var results=[];\n    for (var part=0; part<blocs.length; part++) {\n        var bloc=blocs[part];\n        var result=[];\n        var lines=bloc.split(/[\\r\\n]+/);\n        // first line is the info line\n        var info=lines[0];\n        if (info && info.match(/^[A-Z]/)) {\n            var result=parseInfo(info);\n            result.y=parseData(lines.slice(1));\n            results.push(result);\n        }\n\n    }\n    var spectra=convertToObject(results);\n    addAbsorbanceTransmittance(spectra);\n    addInfo(spectra, options.info);\n    process(spectra, options);\n    addX(spectra);\n    addTabDelimited(spectra);\n\n    return spectra;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parse.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\n// process spectra\n\nfunction smooth(spectrum, nbPixels) {\n    var result=[];\n    var array=spectrum.y;\n    var shift=Math.floor(nbPixels/2);\n\n    for (var i=shift; i<(array.length-shift-1); i++) {\n        var average=0;\n        for (var j=i-shift; j<i-shift+nbPixels; j++) {\n            average+=array[j];\n        }\n        result.push(average/nbPixels)\n    }\n\n    spectrum.y=result;\n    // need to shift the reference point\n    spectrum.redPoint-=shift;\n    spectrum.bluePoint-=shift;\n    spectrum.greenPoint-=shift;\n};\n\nfunction normalize(spectrum) {\n    var array=spectrum.y;\n    var min=Number.MAX_VALUE;\n    var max=Number.MIN_VALUE;\n    for (var i=0; i<array.length; i++) {\n        if (array[i]<min) min=array[i];\n        if (array[i]>max) max=array[i];\n    }\n    if (min!=max) {\n        for (var i=0; i<array.length; i++) {\n            array[i]=(array[i]-min)/(max-min);\n        }\n    } else {\n        for (var i=0; i<array.length; i++) {\n            array[i]=0.5;\n        }\n    }\n    spectrum.y=array;\n}\n\nmodule.exports=function(spectra, options) {\n    var options=Object.create(options||{});\n\n    for (var key in spectra) {\n        if (options.smooth) {\n            smooth(spectra[key], options.smooth);\n        }\n        if (options.normalize) {\n            normalize(spectra[key]);\n        }\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/process.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports.toXY=function(spectrum) {\n    var x=spectrum.x;\n    var y=spectrum.y;\n    var result=[];\n    for (var i=0; i< x.length; i++) {\n        result.push(x[i]+\"\\t\"+y[i]);\n    }\n    return result.join('\\r\\n');\n}\n\nmodule.exports.toArray=function(spectra) {\n    var array=[];\n    for (var key in spectra) {\n        array.push(spectra[key]);\n    }\n    return array;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar wavelengthToColor = require('./wavelengthToColor');\n\n\nfunction getAnnotation(pixel, color, height) {\n    return {\n        \"fillColor\": color,\n        \"type\": \"rect\",\n        \"position\": [{\n            \"y\": \"0px\",\n            \"x\": pixel+2\n        },{\n            \"y\": height+\"px\",\n            \"x\": pixel-1\n        }],\n        \"strokeWidth\":0.0001\n    };\n}\n\nmodule.exports=function(spectrum) {\n    if (! spectrum) return;\n    var annotations=[];\n    annotations.push(getAnnotation(spectrum.nMRed,\"red\",15));\n    annotations.push(getAnnotation(spectrum.nMBlue,\"blue\",15));\n    annotations.push(getAnnotation(spectrum.nMGreen,\"green\",15));\n\n    var x=spectrum.x;\n    for (var i=0; i<x.length; i++) {\n        var color=wavelengthToColor(x[i]).color;\n        annotations.push(getAnnotation(x[i],color,10));\n    }\n    return annotations;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/getAnnotations.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\n// convert an experiment, an array of spectra, to a chart\n\nvar types=require('./types.js');\n\n\n\nmodule.exports=function (experiments, options) {\n    var options=options || {};\n    var channels=options.channels || 'RGBWT';\n    var index=options.index;\n\n    if (! Array.isArray(experiments)) experiments=[experiments];\n\n    var yLabel=\"Y axis\";\n    if (channels.length===1) {\n        yLabel=types[channels].label + \"(\"+types[channels].yUnit+\")\";\n    }\n\n    var chart = {\n        title: \"Open Spectrophotometer results\",\n        \"axis\": [\n            {\n                \"label\": \"Wavelength (nm)\"\n            },\n            {\n                \"label\": yLabel\n            }\n        ],\n        \"data\": []\n    }\n\n    var counter=0;\n\n    var showName=false;\n    var showConcentration=false;\n    var showComment=false;\n    var showChannel=(channels.length===1) ? false : true;\n\n    experiments.forEach(function(experiment) {\n        experiment.info=experiment.info || {};\n    });\n\n    for (var i=1; i<experiments.length; i++) {\n        if (experiments[0].info.concentration !== experiments[i].info.concentration ) showConcentration=true;\n        if (experiments[0].info.name !== experiments[i].info.name ) showName=true;\n        if (experiments[0].info.comment !== experiments[i].info.comment ) showComment=true;\n    }\n\n    for (var i = 0; i < experiments.length; i++) {\n        if ((index === undefined) || (index === i)) {\n            var experiment=experiments[i];\n            for (var key in experiment) {\n                if (channels.indexOf(key)>-1) {\n                    var data=experiment[key];\n\n                    var label=\"\";\n                    if (showName) label+=data.info.name;\n                    if (showConcentration) {\n                        if (showName) label+=' ('+data.info.concentration+')';\n                        else label+=data.info.concentration;\n                    }\n                    if (showComment) {\n                        if (label) label+=' ';\n                        label+=data.info.comment;\n                    }\n                    if (showChannel) {\n                        if (label) label+=' ';\n                        label+=key;\n                    }\n\n                    chart.data.push({\n                        \"x\":data.x,\n                        \"y\":data.y,\n                        \"label\":label,\n                        xAxis: 0,\n                        yAxis: 1,\n                        defaultStyle: {\n                            lineColor: types[key].color,\n                            lineWidth: 2\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    return {\n        type:'chart',\n        value: chart\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/getChart.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\n/*\n types are normally: R G B W\n Z (background), E (experimental)\n A: absorbance\n T: transmittance\n */\n\nmodule.exports = {\n    R:{label:'red', yUnit:\"relative\", color:'red'},\n    G:{label:'green', yUnit:\"relative\", color:'green'},\n    B:{label:'blue', yUnit:\"relative\", color:'blue'},\n    W:{label:'white', yUnit:\"relative\", color:'black'},\n    Z:{label:'background', yUnit:\"relative\", color:'grey'},\n    E:{label:'experimental', yUnit:\"relative\", color:'black'},\n    A:{label:'absorbance', yUnit:\"(%)\", color:'black'},\n    T:{label:'transmittance', yUnit:\"(%)\", color:'black'}\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\n// convert experiments to a tab-delimited file\n\nvar headers=[];\nheaders[0]=[]; // name\nheaders[1]=[]; // concentration\nheaders[2]=[]; // comment\nheaders[3]=[]; // type\n\nmodule.exports=function (experiments, channels, index) {\n    var channels = channels || 'RGBWT';\n\n    if (! Array.isArray(experiments)) experiments=[experiments];\n\n    var data=[];\n\n\n\n    var counter=0;\n    for (var i = 0; i < experiments.length; i++) {\n        if ((index === undefined) || (index === i)) {\n            var experiment=experiments[i];\n\n            addHeaders(experiment, 'X');\n            var currentData=experiment[Object.keys(experiment)[0]];\n            for (var j=0; j<currentData.x.length; j++) {\n                if (! data[j]) data[j]=[];\n                data[j].push(currentData.x[j].toPrecision(4));\n            }\n\n            for (var key in experiment) {\n                if (channels.indexOf(key)>-1) {\n                    addHeaders(experiment,key);\n                    var currentData=experiment[key];\n                    for (var j=0; j<currentData.y.length; j++) {\n                        data[j].push(currentData.y[j].toPrecision(4));\n                    }\n                }\n            }\n        }\n    }\n\n    var lines=[];\n    for (var i=0; i<headers.length; i++) {\n        var header=headers[i];\n        lines.push(header.join(\"\\t\"));\n    }\n    for (var i=0; i<data.length; i++) {\n        var datum=data[i];\n        lines.push(datum.join(\"\\t\"));\n    }\n    var result=lines.join(\"\\r\\n\");\n    return result;\n\n}\n\nfunction addHeaders(experiment, type) {\n    headers[0].push(experiment.info.name);\n    headers[1].push(experiment.info.concentration);\n    headers[2].push(experiment.info.comment);\n    headers[3].push(type);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/getTabDelimited.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\nvar parse=require('./parse.js');\n\n// We load a json containing all the einformations\n\n\nmodule.exports = function (selected, options) {\n    var options=Object.create(options||{});\n    var experiments=[];\n    selected.forEach(function(current) {\n        options.info=current;\n        var experiment=parse(current.data, options);\n        experiments.push(experiment);\n    });\n    return experiments;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/load.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}