{"version":3,"sources":["webpack:///open-spectro/webpack/universalModuleDefinition","webpack:///open-spectro/open-spectro.min.js","webpack:///open-spectro/webpack/bootstrap 06e255271cb979b17649","webpack:///open-spectro/./src/index.js","webpack:///open-spectro/./src/wavelengthToColor.js","webpack:///open-spectro/./src/parse.js","webpack:///open-spectro/./src/process.js","webpack:///open-spectro/./src/util.js","webpack:///open-spectro/./src/getAnnotations.js","webpack:///open-spectro/./src/getChart.js","webpack:///open-spectro/./src/types.js","webpack:///open-spectro/./src/getTabDelimited.js","webpack:///open-spectro/./src/load.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","wavelengthToColor","parse","process","getAnnotations","Util","getChart","getTabDelimited","load","wavelengthTocolor","wavelength","red","green","blue","alpha","color","absorbance","experiment","reference","results","Array","length","i","Math","log10","transmittance","parseData","lines","y","currentValue","fields","split","j","field","trim","match","firstChar","substring","value","difference","indexOf","substr","push","parseInfo","info","result","type","fieldType","replace","fieldValue","intensity","percentIntensity","round","values","redPoint","greenPoint","bluePoint","nMRed","nMGreen","nMBlue","backgroundMin","backgroundMax","convertToObject","spectra","spectrum","addInfo","options","console","log","key","Object","keys","name","addAbsorbanceTransmittance","Z","E","a","JSON","stringify","A","t","T","addTabDelimited","tab","toXY","addX","diffPoints","diffNM","firstNM","lastNM","x","text","create","blocs","part","bloc","slice","smooth","nbPixels","array","shift","floor","average","normalize","min","Number","MAX_VALUE","max","MIN_VALUE","join","toArray","getAnnotation","pixel","height","fillColor","position","strokeWidth","annotations","types","experiments","channels","index","isArray","chart","title","axis","label","data","counter","undefined","concentration","xAxis","yAxis","lineWidth","R","yUnit","G","B","W","addHeaders","headers","comment","currentData","header","datum","selected","forEach","current"],"mappings":"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","file":"open-spectro.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openSpectro\"] = factory();\n\telse\n\t\troot[\"openSpectro\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openSpectro\"] = factory();\n\telse\n\t\troot[\"openSpectro\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar wavelengthToColor = __webpack_require__(1);\n\tvar parse = __webpack_require__(2);\n\tvar process = __webpack_require__(3);\n\tvar getAnnotations = __webpack_require__(5);\n\tvar Util = __webpack_require__(4);\n\tvar getChart = __webpack_require__(6);\n\tvar getTabDelimited = __webpack_require__(8);\n\tvar load = __webpack_require__(9);\n\t\n\tmodule.exports.wavelengthTocolor=wavelengthToColor;\n\tmodule.exports.parse=parse;\n\tmodule.exports.process=process;\n\tmodule.exports.getAnnotations=getAnnotations;\n\tmodule.exports.Util=Util;\n\tmodule.exports.getChart=getChart;\n\tmodule.exports.getTabDelimited=getTabDelimited;\n\tmodule.exports.load=load;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function (wavelength) {\n\t    var red;\n\t    var green;\n\t    var blue;\n\t    var alpha;\n\t\n\t    if (wavelength >= 380 && wavelength < 440) {\n\t        red = -1 * (wavelength - 440) / (440 - 380);\n\t        green = 0;\n\t        blue = 1;\n\t    } else if (wavelength >= 440 && wavelength < 490) {\n\t        red = 0;\n\t        green = (wavelength - 440) / (490 - 440);\n\t        blue = 1;\n\t    } else if (wavelength >= 490 && wavelength < 510) {\n\t        red = 0;\n\t        green = 1;\n\t        blue = -1 * (wavelength - 510) / (510 - 490);\n\t    } else if (wavelength >= 510 && wavelength < 580) {\n\t        red = (wavelength - 510) / (580 - 510);\n\t        green = 1;\n\t        blue = 0;\n\t    } else if (wavelength >= 580 && wavelength < 645) {\n\t        red = 1;\n\t        green = -1 * (wavelength - 645) / (645 - 580);\n\t        blue = 0.0;\n\t    } else if (wavelength >= 645 && wavelength <= 780) {\n\t        red = 1;\n\t        green = 0;\n\t        blue = 0;\n\t    } else {\n\t        red = 0;\n\t        green = 0;\n\t        blue = 0;\n\t    }\n\t\n\t    // outside visible spectrum\n\t    if (wavelength > 780 || wavelength < 380) {\n\t        alpha = 0;\n\t    } else if (wavelength > 700) {\n\t        alpha = (780 - wavelength) / (780 - 700);\n\t    } else if (wavelength < 420) {\n\t        alpha = (wavelength - 380) / (420 - 380);\n\t    } else {\n\t        alpha = 1;\n\t    }\n\t\n\t    return {\n\t        color: \"rgba(\" + (red * 100) + \"%,\" + (green * 100) + \"%,\" + (blue * 100) + \"%, \" + alpha + \")\",\n\t        red: red,\n\t        green: green,\n\t        blue: blue,\n\t        alpha: alpha\n\t    }\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar process=__webpack_require__(3);\n\tvar Util=__webpack_require__(4);\n\t\n\t\n\tfunction absorbance(experiment, reference) {\n\t    var results=new Array(experiment.length);\n\t    for (var i=0; i<experiment.length; i++) {\n\t        results[i]=-Math.log10(experiment[i]/reference[i]);\n\t    }\n\t    return results;\n\t}\n\t\n\tfunction transmittance(experiment, reference) {\n\t    var results=new Array(experiment.length);\n\t    for (var i=0; i<experiment.length; i++) {\n\t        results[i]=experiment[i]/reference[i]*100;\n\t    }\n\t    return results;\n\t}\n\t\n\t\n\t\n\tvar difference=['r','q','p','o','n','m','l','k','j','%','J','K','L','M','N','O','P','Q','R'];\n\t\n\tfunction parseData(lines) {\n\t    var y=[];\n\t    var currentValue=0;\n\t    for (var i=0; i<lines.length; i++) {\n\t        var line=lines[i];\n\t        var fields=lines[i].split(/( ?(?=[a-zA-Z%])| +(?=[^a-zA-Z%]))/);\n\t        for (var j=0; j<fields.length; j++) {\n\t            var field=fields[j];\n\t            if (field.trim().length>0) {\n\t                // we check if we convert the first character\n\t                if (field.match(/^[j-rJ-R%]/)) {\n\t                    var firstChar=field.substring(0,1);\n\t                    var value=difference.indexOf(firstChar)-9;\n\t                    currentValue+=(value+field.substr(1))>>0;\n\t                } else {\n\t                    currentValue=fields[j]>>0;\n\t                }\n\t                y.push(currentValue);\n\t            }\n\t        }\n\t    }\n\t    return y;\n\t}\n\t\n\t\n\t\n\tfunction parseInfo(info) {\n\t    var result={};\n\t    var fields=info.split(\",\");\n\t    result.type=fields[0];\n\t    for (var i=1; i<fields.length; i++) {\n\t        var field=fields[i];\n\t        var fieldType=field.replace(/^([A-Z]*)(.*)$/,\"$1\");\n\t        var fieldValue=field.replace(/^([A-Z]*)(.*)$/,\"$2\");\n\t        switch(fieldType) {\n\t            case 'I':\n\t                result.intensity=fieldValue>>0;\n\t                result.percentIntensity=Math.round(((fieldValue>>0)/256)*100);\n\t                break;\n\t            case 'RGB':\n\t                var values=fieldValue.split(\"/\");\n\t                result.redPoint=values[0]>>0;\n\t                result.greenPoint=values[1]>>0;\n\t                result.bluePoint=values[2]>>0;\n\t                break;\n\t            case 'REF':\n\t                var values=fieldValue.split(\"/\");\n\t                result.nMRed=values[0]>>0;\n\t                result.nMGreen=values[1]>>0;\n\t                result.nMBlue=values[2]>>0;\n\t                break;\n\t            case 'BG':\n\t                var values=fieldValue.split(\"/\");\n\t                result.backgroundMin=values[0]>>0;\n\t                result.backgroundMax=values[1]>>0;\n\t                break;\n\t            default:\n\t                result[fieldType]=fieldValue;\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\t/*\n\t types are normally: R G B W\n\t Z (background), E (experimental)\n\t A: absorbance\n\t T: transmittance\n\t  */\n\t\n\tfunction convertToObject(spectra) {\n\t    var result={};\n\t    for (var i=0; i<spectra.length; i++) {\n\t        var spectrum=spectra[i];\n\t        result[spectrum.type]=spectrum;\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction addInfo(spectra, info) {\n\t    var options=options || {};\n\t    console.log(\"------\");\n\t    for (var type in spectra) {\n\t        var spectrum=spectra[type];\n\t        for (var key in Object.keys(info)) {\n\t            console.log(key);\n\t            spectrum.info = spectrum.info || {};\n\t            if (key!=='data') {\n\t                spectrum.info[key]=info;\n\t            }\n\t        }\n\t        spectrum.name = options.name;\n\t    }\n\t}\n\t\n\tfunction addAbsorbanceTransmittance(spectra) {\n\t    // if we have Z and E we calculate absorbance and transmittance\n\t    if (spectra.Z && spectra.E) {\n\t        var a=JSON.parse(JSON.stringify(spectra.Z));\n\t        a.type=\"A\";\n\t        a.y=absorbance(spectra.E.y, spectra.Z.y);\n\t        spectra.A=a;\n\t        var t=JSON.parse(JSON.stringify(spectra.Z));\n\t        t.type=\"T\";\n\t        t.y=transmittance(spectra.E.y, spectra.Z.y);\n\t        spectra.T=t;\n\t    }\n\t}\n\t\n\tfunction addTabDelimited(spectra) {\n\t    for (var key in spectra) {\n\t        var spectrum = spectra[key];\n\t        spectrum.tab = Util.toXY(spectrum);\n\t    }\n\t}\n\t\n\tfunction addX(spectra) {\n\t    for (var key in spectra) {\n\t        var spectrum=spectra[key];\n\t        var diffPoints=spectrum.redPoint-spectrum.bluePoint;\n\t        var diffNM=(spectrum.nMRed-spectrum.nMBlue)/(diffPoints-1);\n\t        var length=spectrum.y.length;\n\t\n\t        // we will add all the color spectrum\n\t        // need to guess the nm of the first point and last point\n\t        var firstNM=spectrum.nMBlue-spectrum.bluePoint*diffNM;\n\t        var lastNM=spectrum.nMRed+(length-spectrum.redPoint)*diffNM;\n\t        spectrum.x=[];\n\t        for (var i=0; i<length; i++) {\n\t            var wavelength=firstNM+(lastNM-firstNM)/(length-1)*i;\n\t            spectrum.x.push(wavelength);\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports = function (text, options) {\n\t    if (! text) return [];\n\t    var options=Object.create(options || {});\n\t    options.name=options.name||'';\n\t    var blocs=text.split(/[\\r\\n]*>/m);\n\t    var results=[];\n\t    for (var part=0; part<blocs.length; part++) {\n\t        var bloc=blocs[part];\n\t        var result=[];\n\t        var lines=bloc.split(/[\\r\\n]+/);\n\t        // first line is the info line\n\t        var info=lines[0];\n\t        if (info && info.match(/^[A-Z]/)) {\n\t            var result=parseInfo(info);\n\t            result.y=parseData(lines.slice(1));\n\t            results.push(result);\n\t        }\n\t\n\t    }\n\t    var spectra=convertToObject(results);\n\t    addAbsorbanceTransmittance(spectra);\n\t    addInfo(spectra, options.info);\n\t    process(spectra, options);\n\t    addX(spectra);\n\t    addTabDelimited(spectra);\n\t\n\t    return spectra;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// process spectra\n\t\n\tfunction smooth(spectrum, nbPixels) {\n\t    var result=[];\n\t    var array=spectrum.y;\n\t    var shift=Math.floor(nbPixels/2);\n\t\n\t    for (var i=shift; i<(array.length-shift-1); i++) {\n\t        var average=0;\n\t        for (var j=i-shift; j<i-shift+nbPixels; j++) {\n\t            average+=array[j];\n\t        }\n\t        result.push(average/nbPixels)\n\t    }\n\t\n\t    spectrum.y=result;\n\t    // need to shift the reference point\n\t    spectrum.redPoint-=shift;\n\t    spectrum.bluePoint-=shift;\n\t    spectrum.greenPoint-=shift;\n\t};\n\t\n\tfunction normalize(spectrum) {\n\t    var array=spectrum.y;\n\t    var min=Number.MAX_VALUE;\n\t    var max=Number.MIN_VALUE;\n\t    for (var i=0; i<array.length; i++) {\n\t        if (array[i]<min) min=array[i];\n\t        if (array[i]>max) max=array[i];\n\t    }\n\t    if (min!=max) {\n\t        for (var i=0; i<array.length; i++) {\n\t            array[i]=(array[i]-min)/(max-min);\n\t        }\n\t    } else {\n\t        for (var i=0; i<array.length; i++) {\n\t            array[i]=0.5;\n\t        }\n\t    }\n\t    spectrum.y=array;\n\t}\n\t\n\tmodule.exports=function(spectra, options) {\n\t    var options=Object.create(options||{});\n\t\n\t    for (var key in spectra) {\n\t        if (options.smooth) {\n\t            smooth(spectra[key], options.smooth);\n\t        }\n\t        if (options.normalize) {\n\t            normalize(spectra[key]);\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports.toXY=function(spectrum) {\n\t    var x=spectrum.x;\n\t    var y=spectrum.y;\n\t    var result=[];\n\t    for (var i=0; i< x.length; i++) {\n\t        result.push(x[i]+\"\\t\"+y[i]);\n\t    }\n\t    return result.join('\\r\\n');\n\t}\n\t\n\tmodule.exports.toArray=function(spectra) {\n\t    var array=[];\n\t    for (var key in spectra) {\n\t        array.push(spectra[key]);\n\t    }\n\t    return array;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar wavelengthToColor = __webpack_require__(1);\n\t\n\t\n\tfunction getAnnotation(pixel, color, height) {\n\t    return {\n\t        \"fillColor\": color,\n\t        \"type\": \"rect\",\n\t        \"position\": [{\n\t            \"y\": \"0px\",\n\t            \"x\": pixel+2\n\t        },{\n\t            \"y\": height+\"px\",\n\t            \"x\": pixel-1\n\t        }],\n\t        \"strokeWidth\":0.0001\n\t    };\n\t}\n\t\n\tmodule.exports=function(spectrum) {\n\t    if (! spectrum) return;\n\t    var annotations=[];\n\t    annotations.push(getAnnotation(spectrum.nMRed,\"red\",15));\n\t    annotations.push(getAnnotation(spectrum.nMBlue,\"blue\",15));\n\t    annotations.push(getAnnotation(spectrum.nMGreen,\"green\",15));\n\t\n\t    var x=spectrum.x;\n\t    for (var i=0; i<x.length; i++) {\n\t        var color=wavelengthToColor(x[i]).color;\n\t        annotations.push(getAnnotation(x[i],color,10));\n\t    }\n\t    return annotations;\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// convert an experiment, an array of spectra, to a chart\n\t\n\tvar types=__webpack_require__(7);\n\t\n\t\n\t\n\tmodule.exports=function (experiments, channels, index) {\n\t    var channels = channels || 'RGBWT';\n\t\n\t    if (! Array.isArray(experiments)) experiments=[experiments];\n\t\n\t    var chart = {\n\t        type: \"chart\",\n\t        value: {\n\t            title: \"Open Spectrophotometer results\",\n\t            \"axis\": [\n\t                {\n\t                    \"label\": \"nm\"\n\t                },\n\t                {\n\t                    \"label\": \"Y axis\"\n\t                }\n\t            ],\n\t            \"data\": []\n\t        }\n\t    }\n\t    var counter=0;\n\t    for (var i = 0; i < experiments.length; i++) {\n\t        if ((index === undefined) || (index === i)) {\n\t            var experiment=experiments[i];\n\t            for (var key in experiment) {\n\t                if (channels.indexOf(key)>-1) {\n\t                    var data=experiment[key];\n\t                    chart.value.data.push({\n\t                        \"x\":data.x,\n\t                        \"y\":data.y,\n\t                        \"label\":(++counter)+\". \"+types[key].label+(data.name ? ': '+data.name : '')+\n\t                        (data.concentration ? ' ('+data.name+\")\" : '')\n\t                        ,\n\t                        xAxis: 0,\n\t                        yAxis: 1,\n\t                        lineWidth: 2,\n\t                        color: types[key].color\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return chart;\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t types are normally: R G B W\n\t Z (background), E (experimental)\n\t A: absorbance\n\t T: transmittance\n\t */\n\t\n\tmodule.exports = {\n\t    R:{label:'red', yUnit:\"relative\", color:'red'},\n\t    G:{label:'green', yUnit:\"relative\", color:'green'},\n\t    B:{label:'blue', yUnit:\"relative\", color:'blue'},\n\t    W:{label:'white', yUnit:\"relative\", color:'black'},\n\t    Z:{label:'background', yUnit:\"relative\", color:'grey'},\n\t    E:{label:'experimental', yUnit:\"relative\", color:'black'},\n\t    A:{label:'absorbance', yUnit:\"(%), color:'black'\"},\n\t    T:{label:'transmittance', yUnit:\"(%), color:'black'\"},\n\t}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// convert experiments to a tab-delimited file\n\t\n\t\n\t\n\tmodule.exports=function (experiments, channels, index) {\n\t    var channels = channels || 'RGBWT';\n\t\n\t    if (! Array.isArray(experiments)) experiments=[experiments];\n\t\n\t    var data=[];\n\t\n\t    var headers=[];\n\t    headers[0]=[]; // name\n\t    headers[1]=[]; // concentration\n\t    headers[2]=[]; // comment\n\t    headers[3]=[]; // type\n\t\n\t    var counter=0;\n\t    for (var i = 0; i < experiments.length; i++) {\n\t        if ((index === undefined) || (index === i)) {\n\t            var experiment=experiments[i];\n\t\n\t            addHeaders(experiment, 'X');\n\t            var currentData=experiment[Object.keys(experiment)[0]];\n\t            for (var j=0; j<currentData.x.length; j++) {\n\t                if (! data[j]) data[j]=[];\n\t                data[j].push(currentData.x[j]);\n\t            }\n\t\n\t            for (var key in experiment) {\n\t                if (channels.indexOf(key)>-1) {\n\t                    addHeaders(experiment,key);\n\t                    var currentData=experiment[key];\n\t                    for (var j=0; j<currentData.y.length; j++) {\n\t                        data[j].push(currentData.y[j]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    var lines=[];\n\t    for (var i=0; i<headers.length; i++) {\n\t        var header=headers[i];\n\t        lines.push(header.join(\"\\t\"));\n\t    }\n\t    for (var i=0; i<data.length; i++) {\n\t        var datum=data[i];\n\t        lines.push(datum.join(\"\\t\"));\n\t    }\n\t    var result=lines.join(\"\\r\");\n\t    return result;\n\t\n\t    function addHeaders(headers, experiment, type) {\n\t        headers[0].push(experiment.info.name);\n\t        headers[1].push(experiment.info.concentration);\n\t        headers[2].push(experiment.info.comment);\n\t        headers[3].push(type);\n\t    }\n\t\n\t}\n\t\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar parse=__webpack_require__(2);\n\t\n\t// We load a json containing all the einformations\n\t\n\t\n\tmodule.exports = function (selected, options) {\n\t    var options=Object.create(options||{});\n\t    var experiments=[];\n\t    selected.forEach(function(current) {\n\t        options.info=JSON.parse(JSON.stringify(current));\n\t        var experiment=parse(current.data, options);\n\t        experiments.push(experiment);\n\t    });\n\t    return experiments;\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** open-spectro.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 06e255271cb979b17649\n **/","'use strict';\n\n\nvar wavelengthToColor = require('./wavelengthToColor');\nvar parse = require('./parse');\nvar process = require('./process');\nvar getAnnotations = require('./getAnnotations');\nvar Util = require('./util');\nvar getChart = require('./getChart');\nvar getTabDelimited = require('./getTabDelimited');\nvar load = require('./load');\n\nmodule.exports.wavelengthTocolor=wavelengthToColor;\nmodule.exports.parse=parse;\nmodule.exports.process=process;\nmodule.exports.getAnnotations=getAnnotations;\nmodule.exports.Util=Util;\nmodule.exports.getChart=getChart;\nmodule.exports.getTabDelimited=getTabDelimited;\nmodule.exports.load=load;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function (wavelength) {\n    var red;\n    var green;\n    var blue;\n    var alpha;\n\n    if (wavelength >= 380 && wavelength < 440) {\n        red = -1 * (wavelength - 440) / (440 - 380);\n        green = 0;\n        blue = 1;\n    } else if (wavelength >= 440 && wavelength < 490) {\n        red = 0;\n        green = (wavelength - 440) / (490 - 440);\n        blue = 1;\n    } else if (wavelength >= 490 && wavelength < 510) {\n        red = 0;\n        green = 1;\n        blue = -1 * (wavelength - 510) / (510 - 490);\n    } else if (wavelength >= 510 && wavelength < 580) {\n        red = (wavelength - 510) / (580 - 510);\n        green = 1;\n        blue = 0;\n    } else if (wavelength >= 580 && wavelength < 645) {\n        red = 1;\n        green = -1 * (wavelength - 645) / (645 - 580);\n        blue = 0.0;\n    } else if (wavelength >= 645 && wavelength <= 780) {\n        red = 1;\n        green = 0;\n        blue = 0;\n    } else {\n        red = 0;\n        green = 0;\n        blue = 0;\n    }\n\n    // outside visible spectrum\n    if (wavelength > 780 || wavelength < 380) {\n        alpha = 0;\n    } else if (wavelength > 700) {\n        alpha = (780 - wavelength) / (780 - 700);\n    } else if (wavelength < 420) {\n        alpha = (wavelength - 380) / (420 - 380);\n    } else {\n        alpha = 1;\n    }\n\n    return {\n        color: \"rgba(\" + (red * 100) + \"%,\" + (green * 100) + \"%,\" + (blue * 100) + \"%, \" + alpha + \")\",\n        red: red,\n        green: green,\n        blue: blue,\n        alpha: alpha\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/wavelengthToColor.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\nvar process=require('./process.js');\nvar Util=require('./util.js');\n\n\nfunction absorbance(experiment, reference) {\n    var results=new Array(experiment.length);\n    for (var i=0; i<experiment.length; i++) {\n        results[i]=-Math.log10(experiment[i]/reference[i]);\n    }\n    return results;\n}\n\nfunction transmittance(experiment, reference) {\n    var results=new Array(experiment.length);\n    for (var i=0; i<experiment.length; i++) {\n        results[i]=experiment[i]/reference[i]*100;\n    }\n    return results;\n}\n\n\n\nvar difference=['r','q','p','o','n','m','l','k','j','%','J','K','L','M','N','O','P','Q','R'];\n\nfunction parseData(lines) {\n    var y=[];\n    var currentValue=0;\n    for (var i=0; i<lines.length; i++) {\n        var line=lines[i];\n        var fields=lines[i].split(/( ?(?=[a-zA-Z%])| +(?=[^a-zA-Z%]))/);\n        for (var j=0; j<fields.length; j++) {\n            var field=fields[j];\n            if (field.trim().length>0) {\n                // we check if we convert the first character\n                if (field.match(/^[j-rJ-R%]/)) {\n                    var firstChar=field.substring(0,1);\n                    var value=difference.indexOf(firstChar)-9;\n                    currentValue+=(value+field.substr(1))>>0;\n                } else {\n                    currentValue=fields[j]>>0;\n                }\n                y.push(currentValue);\n            }\n        }\n    }\n    return y;\n}\n\n\n\nfunction parseInfo(info) {\n    var result={};\n    var fields=info.split(\",\");\n    result.type=fields[0];\n    for (var i=1; i<fields.length; i++) {\n        var field=fields[i];\n        var fieldType=field.replace(/^([A-Z]*)(.*)$/,\"$1\");\n        var fieldValue=field.replace(/^([A-Z]*)(.*)$/,\"$2\");\n        switch(fieldType) {\n            case 'I':\n                result.intensity=fieldValue>>0;\n                result.percentIntensity=Math.round(((fieldValue>>0)/256)*100);\n                break;\n            case 'RGB':\n                var values=fieldValue.split(\"/\");\n                result.redPoint=values[0]>>0;\n                result.greenPoint=values[1]>>0;\n                result.bluePoint=values[2]>>0;\n                break;\n            case 'REF':\n                var values=fieldValue.split(\"/\");\n                result.nMRed=values[0]>>0;\n                result.nMGreen=values[1]>>0;\n                result.nMBlue=values[2]>>0;\n                break;\n            case 'BG':\n                var values=fieldValue.split(\"/\");\n                result.backgroundMin=values[0]>>0;\n                result.backgroundMax=values[1]>>0;\n                break;\n            default:\n                result[fieldType]=fieldValue;\n        }\n    }\n    return result;\n}\n\n/*\n types are normally: R G B W\n Z (background), E (experimental)\n A: absorbance\n T: transmittance\n  */\n\nfunction convertToObject(spectra) {\n    var result={};\n    for (var i=0; i<spectra.length; i++) {\n        var spectrum=spectra[i];\n        result[spectrum.type]=spectrum;\n    }\n    return result;\n}\n\nfunction addInfo(spectra, info) {\n    var options=options || {};\n    console.log(\"------\");\n    for (var type in spectra) {\n        var spectrum=spectra[type];\n        for (var key in Object.keys(info)) {\n            console.log(key);\n            spectrum.info = spectrum.info || {};\n            if (key!=='data') {\n                spectrum.info[key]=info;\n            }\n        }\n        spectrum.name = options.name;\n    }\n}\n\nfunction addAbsorbanceTransmittance(spectra) {\n    // if we have Z and E we calculate absorbance and transmittance\n    if (spectra.Z && spectra.E) {\n        var a=JSON.parse(JSON.stringify(spectra.Z));\n        a.type=\"A\";\n        a.y=absorbance(spectra.E.y, spectra.Z.y);\n        spectra.A=a;\n        var t=JSON.parse(JSON.stringify(spectra.Z));\n        t.type=\"T\";\n        t.y=transmittance(spectra.E.y, spectra.Z.y);\n        spectra.T=t;\n    }\n}\n\nfunction addTabDelimited(spectra) {\n    for (var key in spectra) {\n        var spectrum = spectra[key];\n        spectrum.tab = Util.toXY(spectrum);\n    }\n}\n\nfunction addX(spectra) {\n    for (var key in spectra) {\n        var spectrum=spectra[key];\n        var diffPoints=spectrum.redPoint-spectrum.bluePoint;\n        var diffNM=(spectrum.nMRed-spectrum.nMBlue)/(diffPoints-1);\n        var length=spectrum.y.length;\n\n        // we will add all the color spectrum\n        // need to guess the nm of the first point and last point\n        var firstNM=spectrum.nMBlue-spectrum.bluePoint*diffNM;\n        var lastNM=spectrum.nMRed+(length-spectrum.redPoint)*diffNM;\n        spectrum.x=[];\n        for (var i=0; i<length; i++) {\n            var wavelength=firstNM+(lastNM-firstNM)/(length-1)*i;\n            spectrum.x.push(wavelength);\n        }\n    }\n}\n\nmodule.exports = function (text, options) {\n    if (! text) return [];\n    var options=Object.create(options || {});\n    options.name=options.name||'';\n    var blocs=text.split(/[\\r\\n]*>/m);\n    var results=[];\n    for (var part=0; part<blocs.length; part++) {\n        var bloc=blocs[part];\n        var result=[];\n        var lines=bloc.split(/[\\r\\n]+/);\n        // first line is the info line\n        var info=lines[0];\n        if (info && info.match(/^[A-Z]/)) {\n            var result=parseInfo(info);\n            result.y=parseData(lines.slice(1));\n            results.push(result);\n        }\n\n    }\n    var spectra=convertToObject(results);\n    addAbsorbanceTransmittance(spectra);\n    addInfo(spectra, options.info);\n    process(spectra, options);\n    addX(spectra);\n    addTabDelimited(spectra);\n\n    return spectra;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parse.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\n// process spectra\n\nfunction smooth(spectrum, nbPixels) {\n    var result=[];\n    var array=spectrum.y;\n    var shift=Math.floor(nbPixels/2);\n\n    for (var i=shift; i<(array.length-shift-1); i++) {\n        var average=0;\n        for (var j=i-shift; j<i-shift+nbPixels; j++) {\n            average+=array[j];\n        }\n        result.push(average/nbPixels)\n    }\n\n    spectrum.y=result;\n    // need to shift the reference point\n    spectrum.redPoint-=shift;\n    spectrum.bluePoint-=shift;\n    spectrum.greenPoint-=shift;\n};\n\nfunction normalize(spectrum) {\n    var array=spectrum.y;\n    var min=Number.MAX_VALUE;\n    var max=Number.MIN_VALUE;\n    for (var i=0; i<array.length; i++) {\n        if (array[i]<min) min=array[i];\n        if (array[i]>max) max=array[i];\n    }\n    if (min!=max) {\n        for (var i=0; i<array.length; i++) {\n            array[i]=(array[i]-min)/(max-min);\n        }\n    } else {\n        for (var i=0; i<array.length; i++) {\n            array[i]=0.5;\n        }\n    }\n    spectrum.y=array;\n}\n\nmodule.exports=function(spectra, options) {\n    var options=Object.create(options||{});\n\n    for (var key in spectra) {\n        if (options.smooth) {\n            smooth(spectra[key], options.smooth);\n        }\n        if (options.normalize) {\n            normalize(spectra[key]);\n        }\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/process.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports.toXY=function(spectrum) {\n    var x=spectrum.x;\n    var y=spectrum.y;\n    var result=[];\n    for (var i=0; i< x.length; i++) {\n        result.push(x[i]+\"\\t\"+y[i]);\n    }\n    return result.join('\\r\\n');\n}\n\nmodule.exports.toArray=function(spectra) {\n    var array=[];\n    for (var key in spectra) {\n        array.push(spectra[key]);\n    }\n    return array;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar wavelengthToColor = require('./wavelengthToColor');\n\n\nfunction getAnnotation(pixel, color, height) {\n    return {\n        \"fillColor\": color,\n        \"type\": \"rect\",\n        \"position\": [{\n            \"y\": \"0px\",\n            \"x\": pixel+2\n        },{\n            \"y\": height+\"px\",\n            \"x\": pixel-1\n        }],\n        \"strokeWidth\":0.0001\n    };\n}\n\nmodule.exports=function(spectrum) {\n    if (! spectrum) return;\n    var annotations=[];\n    annotations.push(getAnnotation(spectrum.nMRed,\"red\",15));\n    annotations.push(getAnnotation(spectrum.nMBlue,\"blue\",15));\n    annotations.push(getAnnotation(spectrum.nMGreen,\"green\",15));\n\n    var x=spectrum.x;\n    for (var i=0; i<x.length; i++) {\n        var color=wavelengthToColor(x[i]).color;\n        annotations.push(getAnnotation(x[i],color,10));\n    }\n    return annotations;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/getAnnotations.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\n// convert an experiment, an array of spectra, to a chart\n\nvar types=require('./types.js');\n\n\n\nmodule.exports=function (experiments, channels, index) {\n    var channels = channels || 'RGBWT';\n\n    if (! Array.isArray(experiments)) experiments=[experiments];\n\n    var chart = {\n        type: \"chart\",\n        value: {\n            title: \"Open Spectrophotometer results\",\n            \"axis\": [\n                {\n                    \"label\": \"nm\"\n                },\n                {\n                    \"label\": \"Y axis\"\n                }\n            ],\n            \"data\": []\n        }\n    }\n    var counter=0;\n    for (var i = 0; i < experiments.length; i++) {\n        if ((index === undefined) || (index === i)) {\n            var experiment=experiments[i];\n            for (var key in experiment) {\n                if (channels.indexOf(key)>-1) {\n                    var data=experiment[key];\n                    chart.value.data.push({\n                        \"x\":data.x,\n                        \"y\":data.y,\n                        \"label\":(++counter)+\". \"+types[key].label+(data.name ? ': '+data.name : '')+\n                        (data.concentration ? ' ('+data.name+\")\" : '')\n                        ,\n                        xAxis: 0,\n                        yAxis: 1,\n                        lineWidth: 2,\n                        color: types[key].color\n                    });\n                }\n            }\n        }\n    }\n\n    return chart;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/getChart.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\n/*\n types are normally: R G B W\n Z (background), E (experimental)\n A: absorbance\n T: transmittance\n */\n\nmodule.exports = {\n    R:{label:'red', yUnit:\"relative\", color:'red'},\n    G:{label:'green', yUnit:\"relative\", color:'green'},\n    B:{label:'blue', yUnit:\"relative\", color:'blue'},\n    W:{label:'white', yUnit:\"relative\", color:'black'},\n    Z:{label:'background', yUnit:\"relative\", color:'grey'},\n    E:{label:'experimental', yUnit:\"relative\", color:'black'},\n    A:{label:'absorbance', yUnit:\"(%), color:'black'\"},\n    T:{label:'transmittance', yUnit:\"(%), color:'black'\"},\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/types.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\n// convert experiments to a tab-delimited file\n\n\n\nmodule.exports=function (experiments, channels, index) {\n    var channels = channels || 'RGBWT';\n\n    if (! Array.isArray(experiments)) experiments=[experiments];\n\n    var data=[];\n\n    var headers=[];\n    headers[0]=[]; // name\n    headers[1]=[]; // concentration\n    headers[2]=[]; // comment\n    headers[3]=[]; // type\n\n    var counter=0;\n    for (var i = 0; i < experiments.length; i++) {\n        if ((index === undefined) || (index === i)) {\n            var experiment=experiments[i];\n\n            addHeaders(experiment, 'X');\n            var currentData=experiment[Object.keys(experiment)[0]];\n            for (var j=0; j<currentData.x.length; j++) {\n                if (! data[j]) data[j]=[];\n                data[j].push(currentData.x[j]);\n            }\n\n            for (var key in experiment) {\n                if (channels.indexOf(key)>-1) {\n                    addHeaders(experiment,key);\n                    var currentData=experiment[key];\n                    for (var j=0; j<currentData.y.length; j++) {\n                        data[j].push(currentData.y[j]);\n                    }\n                }\n            }\n        }\n    }\n\n    var lines=[];\n    for (var i=0; i<headers.length; i++) {\n        var header=headers[i];\n        lines.push(header.join(\"\\t\"));\n    }\n    for (var i=0; i<data.length; i++) {\n        var datum=data[i];\n        lines.push(datum.join(\"\\t\"));\n    }\n    var result=lines.join(\"\\r\");\n    return result;\n\n    function addHeaders(headers, experiment, type) {\n        headers[0].push(experiment.info.name);\n        headers[1].push(experiment.info.concentration);\n        headers[2].push(experiment.info.comment);\n        headers[3].push(type);\n    }\n\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/getTabDelimited.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\nvar parse=require('./parse.js');\n\n// We load a json containing all the einformations\n\n\nmodule.exports = function (selected, options) {\n    var options=Object.create(options||{});\n    var experiments=[];\n    selected.forEach(function(current) {\n        options.info=JSON.parse(JSON.stringify(current));\n        var experiment=parse(current.data, options);\n        experiments.push(experiment);\n    });\n    return experiments;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/load.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}